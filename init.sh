#!/bin/bash

# VLE7 Complete End-to-End Blue-Green Deployment Setup
# This script automates the entire infrastructure setup process

set -e  # Exit on any error

# Configuration
PROJECT_NAME="vle7-app"
REGION="us-east-1"
INSTANCE_TYPE="t3.small"
KEY_NAME="yasinkey"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')] $1${NC}"
}

warn() {
    echo -e "${YELLOW}[$(date +'%Y-%m-%d %H:%M:%S')] WARNING: $1${NC}"
}

error() {
    echo -e "${RED}[$(date +'%Y-%m-%d %H:%M:%S')] ERROR: $1${NC}"
}

info() {
    echo -e "${BLUE}[$(date +'%Y-%m-%d %H:%M:%S')] INFO: $1${NC}"
}

# Function to check prerequisites
check_prerequisites() {
    log "ðŸ” Checking prerequisites..."
    
    # Check if running on macOS
    if [[ "$OSTYPE" != "darwin"* ]]; then
        error "This script is designed for macOS. Please adapt for your OS."
        exit 1
    fi
    
    # Check required tools
    local required_tools=("terraform" "ansible" "aws" "ssh")
    local missing_tools=()
    
    for tool in "${required_tools[@]}"; do
        if ! command -v $tool &> /dev/null; then
            missing_tools+=($tool)
        fi
    done
    
    if [ ${#missing_tools[@]} -ne 0 ]; then
        error "Missing required tools: ${missing_tools[*]}"
        info "Please install missing tools and run again"
        exit 1
    fi
    
    # Check AWS credentials
    if ! aws sts get-caller-identity &> /dev/null; then
        error "AWS credentials not configured"
        info "Please run 'aws configure' to set up your AWS credentials"
        exit 1
    fi
    
    # Check SSH key
    if [ ! -f ~/.ssh/${KEY_NAME}.pem ]; then
        error "SSH key ~/.ssh/${KEY_NAME}.pem not found"
        info "Please ensure your AWS key pair is saved as ~/.ssh/${KEY_NAME}.pem"
        exit 1
    fi
    
    log "âœ… All prerequisites met!"
}

# Function to setup directory structure
setup_directories() {
    log "ðŸ“ Setting up directory structure..."
    
    # Ensure we're in the right directory
    if [ ! -f "Jenkinsfile" ]; then
        error "Please run this script from the VLE7 project root directory"
        exit 1
    fi
    
    # Ensure all required directories exist
    mkdir -p jenkins
    mkdir -p scripts
    
    # Ensure terraform directory exists
    if [ ! -d "infra/terraform" ]; then
        error "Terraform directory not found at infra/terraform"
        exit 1
    fi
    
    # Ensure ansible directory exists
    if [ ! -d "infra/ansible" ]; then
        error "Ansible directory not found at infra/ansible"
        exit 1
    fi
    
    log "âœ… Directory structure ready!"
}

# Function to deploy infrastructure
deploy_infrastructure() {
    log "ðŸ—ï¸ Deploying AWS infrastructure with Terraform..."
    
    cd infra/terraform
    
    # Initialize Terraform
    log "Initializing Terraform..."
    terraform init
    
    # Plan the deployment
    log "Planning Terraform deployment..."
    terraform plan -var="project_name=${PROJECT_NAME}" \
                  -var="aws_region=${REGION}" \
                  -var="instance_type=${INSTANCE_TYPE}"
    
    # Apply the deployment
    log "Applying Terraform configuration..."
    terraform apply -auto-approve \
                   -var="project_name=${PROJECT_NAME}" \
                   -var="aws_region=${REGION}" \
                   -var="instance_type=${INSTANCE_TYPE}"
    
    # Get outputs
    INSTANCE_IP=$(terraform output -raw instance_public_ip)
    JENKINS_URL=$(terraform output -raw jenkins_url)
    
    log "âœ… Infrastructure deployed successfully!"
    info "Instance IP: ${INSTANCE_IP}"
    info "Jenkins URL: ${JENKINS_URL}"
    
    cd ../../
}

# Function to wait for instance to be ready
wait_for_instance() {
    log "â³ Waiting for EC2 instance to be fully ready..."
    
    local max_attempts=30
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        info "Attempt $attempt/$max_attempts: Checking SSH connectivity..."
        
        if ssh -i ~/.ssh/${KEY_NAME}.pem -o ConnectTimeout=10 -o StrictHostKeyChecking=no ec2-user@${INSTANCE_IP} "echo 'SSH connection successful'" &> /dev/null; then
            log "âœ… Instance is ready and accessible!"
            return 0
        fi
        
        info "Waiting 30 seconds before next attempt..."
        sleep 30
        ((attempt++))
    done
    
    error "Instance failed to become accessible after $max_attempts attempts"
    exit 1
}

# Function to configure Jenkins
configure_jenkins() {
    log "âš™ï¸ Configuring Jenkins with Ansible..."
    
    cd infra
    
    # Verify inventory file was generated by Terraform
    if [ ! -f "ansible/inventory.ini" ]; then
        error "Ansible inventory not generated. Check Terraform execution."
        exit 1
    fi
    
    log "Using Terraform-generated inventory file"
    
    # Run Ansible playbook
    log "Running Ansible playbook for Jenkins setup..."
    ANSIBLE_HOST_KEY_CHECKING=False ansible-playbook \
        -i infra/ansible/inventory.ini \
        infra/ansible/jenkins_setup.yml \
        -v
    
    log "âœ… Jenkins configuration completed!"
    cd ..
}

# Function to verify setup
verify_setup() {
    log "ðŸ” Verifying complete setup..."
    
    # Check Jenkins accessibility
    info "Checking Jenkins accessibility..."
    local max_attempts=10
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        info "Attempt $attempt/$max_attempts: Testing Jenkins URL..."
        
        if curl -s -f "${JENKINS_URL}" > /dev/null; then
            log "âœ… Jenkins is accessible!"
            break
        fi
        
        if [ $attempt -eq $max_attempts ]; then
            warn "Jenkins may not be fully ready yet. Please wait a few more minutes."
            break
        fi
        
        sleep 30
        ((attempt++))
    done
    
    # SSH into instance and check services
    log "Checking services on the instance..."
    ssh -i ~/.ssh/${KEY_NAME}.pem -o StrictHostKeyChecking=no ec2-user@${INSTANCE_IP} << 'EOF'
        echo "=== Service Status ==="
        sudo systemctl status jenkins --no-pager -l || echo "Jenkins status check failed"
        sudo systemctl status docker --no-pager -l || echo "Docker status check failed"
        
        echo "=== Docker Status ==="
        sudo docker ps || echo "Docker ps failed"
        
        echo "=== Minikube Status ==="
        sudo -u jenkins minikube status || echo "Minikube status check failed"
        
        echo "=== Disk Usage ==="
        df -h
        
        echo "=== Memory Usage ==="
        free -h
EOF
    
    log "âœ… Setup verification completed!"
}

# Function to display final instructions
show_final_instructions() {
    log "ðŸŽ‰ VLE7 Complete Setup Finished!"
    
    echo ""
    echo "=================================="
    echo "    ðŸš€ SETUP COMPLETE! ðŸš€"
    echo "=================================="
    echo ""
    echo "ðŸ“‹ Your VLE7 environment is ready:"
    echo ""
    echo "ðŸŒ Jenkins URL: ${JENKINS_URL}"
    echo "ðŸ”‘ Jenkins Login: admin"
    echo "ðŸ” SSH Command: ssh -i ~/.ssh/${KEY_NAME}.pem ec2-user@${INSTANCE_IP}"
    echo ""
    echo "ðŸ“‹ Next Steps:"
    echo "1. ðŸŒ Access Jenkins at: ${JENKINS_URL}"
    echo "2. ðŸ”‘ Login with username 'admin' (password displayed above)"
    echo "3. â˜¸ï¸ Configure Kubernetes: ./scripts/configure-kubernetes.sh"
    echo "4. ðŸ”— Add GitHub webhook: ${JENKINS_URL}/github-webhook/"
    echo "5. â–¶ï¸ Run the '${PROJECT_NAME}-pipeline' job to test blue-green deployment"
    echo "6. ðŸ“Š Check status anytime: ./scripts/status-check.sh"
    echo ""
    echo "ðŸŽ¯ Pipeline Features:"
    echo "â€¢ ðŸ”µðŸŸ¢ Blue-Green deployment with traffic switching"
    echo "â€¢ ï¿½ Lightweight nginx-based applications"
    echo "â€¢ â˜¸ï¸ Remote Kubernetes cluster support"
    echo "â€¢ ðŸš¦ Manual approval gates for safety"
    echo "â€¢ ðŸ”„ Automatic rollback on failure"
    echo "â€¢ ðŸ’¾ Memory optimized for t3.small instances"
    echo ""
    echo "ðŸ› ï¸ Management Commands:"
    echo "â€¢ Start instance: aws ec2 start-instances --instance-ids \$(cd infra/terraform && terraform output -raw instance_id)"
    echo "â€¢ Stop instance: aws ec2 stop-instances --instance-ids \$(cd infra/terraform && terraform output -raw instance_id)"
    echo "â€¢ Destroy infrastructure: cd infra/terraform && terraform destroy"
    echo ""
    echo "ðŸ“š Access Application:"
    echo "â€¢ SSH to instance: ssh -i ~/.ssh/${KEY_NAME}.pem ec2-user@${INSTANCE_IP}"
    echo "â€¢ Configure K8s: ./scripts/configure-kubernetes.sh"
    echo "â€¢ Port forward: kubectl port-forward service/vle7-app-service 8080:80"
    echo "â€¢ NodePort access: http://<node-ip>:30080"
    echo ""
    echo "ðŸŽŠ Happy deploying with VLE7!"
    echo "=================================="
}

# Function to handle cleanup on script exit
cleanup() {
    if [ $? -ne 0 ]; then
        error "Script failed! Check the logs above for details."
        warn "If infrastructure was partially created, you may need to run 'terraform destroy' manually."
    fi
}

# Main execution
main() {
    log "ðŸš€ Starting VLE7 Complete End-to-End Setup"
    log "Project: ${PROJECT_NAME}"
    log "Region: ${REGION}"
    log "Instance Type: ${INSTANCE_TYPE}"
    
    trap cleanup EXIT
    
    # Execute setup steps
    check_prerequisites
    setup_directories
    deploy_infrastructure
    wait_for_instance
    configure_jenkins
    verify_setup
    show_final_instructions
    
    log "âœ… All setup steps completed successfully!"
}

# Run main function
main "$@"